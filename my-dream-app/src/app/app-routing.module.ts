import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { EventsComponent } from './events/events.component';
import { SpecialEventsComponent } from './special-events/special-events.component';
import { LoginComponent } from './login/login.component';
import { RegisterComponent } from './register/register.component';
import { AuthGuard } from './auth.guard';


const routes: Routes = [
  {path: "events", component: EventsComponent},
  {path: "special", component: SpecialEventsComponent, canActivate: [AuthGuard] /*This guard was required for testing only, to make sure people couldn't just get into the special page without logging in.  However, it was weak because it just verified whether there was a token present or not, not if it's the same token that was generated by the server.  After implementing the verifyToken in the api.js, this is unnecessary.  However, this is still being used because it speeds up the front-end process of verifying if there's a token present (ANY TOKEN, EVEN A FAKE ONE).  If there's no token present, it'll save the trip of going to the api server to go to login.  It'll just send the application to login immediately.  If there's a token present, however, it lets the request be sent to the server and it's up to the server to verify that it's the same token before letting the user see the special page.  As mentioned, this verification is done in the verifyToken method in the api.js file in the server.*/},
  {path: "login", component: LoginComponent},
  {path: "register", component: RegisterComponent},
  {path: "", redirectTo: "/events", pathMatch: 'full'}
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
